## README

[TOC]

### 字面值常量

* 后缀f只能放在浮点型字面值后面，如`1024f`是无效的，必须写成`1024.0f`

### 变量初始化

* 在同一条定义语句中，可以用先定义的变量去初始化后定义的其他变量

  ```c++
  double price = 109.99, discount = price * 0.16;
  ```

* 定义于任何函数体之外的变量，全局变量，被初始化为0。
* 定义于函数体内部的build-in类型变量如果没有初始化，则其值未定义；类的对象如果没有显式初始化，则其值由类确定。

#### 列表初始化

- 全面应用花括号来初始化变量。
- 为变量赋值的时候也可以使用花括号。
- 列表初始化的一个重要特点是：当初始值存在丢失信息的风险时，如`double`转换为`int`，编译器会报错。

```c++
int a = 0;
int a = {0};
int a(0);
int a{0};

long double ld = 3.1415926536;
int a(ld), b = ld;
int c{ld}, d = {ld}; // 这一行是错误的，会丢失信息，编译器会报错
```



### 分离式编译中变量的声明和定义

```c++
int i;           // 声明并定义
int i = 5;       // 声明并定义，初始化
extern int i;    // 声明i而非定义
```

在函数体外部，如果extern语句包含初始值，那么就会抵消extern的作用，该语句不再是声明，而是定义。

在函数体内部，如果对一个extern标记的变量进行初始化，将引发错误。

分离式编译：如果要在多个文件中使用同一个变量，就必须将声明和定义分离。变量的定义只能出现在一个文件中，其他使用该变量的文件必须用extern对其进行声明，但不能重复定义。

### 标识符 （变量名、类名、函数名）

* 由字母、数字、下划线组成，必须以字母或下划线开头，不能以数字开头。
* 用户自定义标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头。
* 定义在函数体外的标识符不能以下划线开头。
* 类名一般以大写字母开头

### 作用域

- 局部：作用域为局部的变量只在它的代码块中可用

- 全局：作用域为全局的变量在定义位置到文件结尾之间都可用

- 嵌套作用域：如果内部作用域定义了与外部作用域相同名称的对象，内部的会把外部的覆盖，如果想调用外部的，需要使用作用域解析操作符（::）

  单单把`::`这个操作符放在变量名称前面时，表示使用变量的全局版本

### 引用

* 在一条语句中定义多个引用或指针，每个变量名前面都要加`&`或`*`。
* 两者指向相同的值和内存单元。
* 声明引用时必须将其初始化，而且不能再引用别的变量，接近一个`const`指针，不能更改指向的对象，但可以改变对象的值。
* 初始化：初始化时，只能使用相同类型的对象，不能使用字面值或者表达式。
* 引用只是给已有的变量又起了一个名字，本质上不是一个对象，因此，**不能定义引用的引用，也不能定义指向引用的指针**

### 指针

定义时可以不初始化。

#### 指向指针的引用

可以定义**指向指针的指针**和**指向指针的引用**

```c++
int i = 42;
int *p;
int *&r = p;     // 注意两个修饰符的位置
r = &i;
*r = 0;
```



#### 空指针

```c++
int *p1 = nullptr;        // C++11新标准
int *p2 = 0;
int *p3 = NULL;
```

`NULL`在头文件`cstdlib`中定义，它的值就是0。

#### void*指针

`void*`是一种特殊的指针类型，可以用于存放任意对象的地址。

用法：和别的指针比较、作为函数的输入和输出、赋值给另外一个`void*`指针。

**不能直接操作它指向的对象。**

### const限定符

#### const限定符对链接性的影响

* 默认情况下，全局变量的链接性为外部的，但是`const`全局变量的链接性是内部的，类似于使用了`static`关键字，`const`对象被设定为仅在当前文件内有效。

* 当多个文件中出现了同名的`const`变量时，其实是在不同文件中分别定义了独立的变量。

* 可以将`const`变量的定义放在头文件，每个文件都有一组自己的变量，私有。

* 如果想在多个文件之间共享`const`对象，必须在对象的定义和声明之前都添加`const`关键字

  ```c++
  // file1.cpp
  extern const int cat = 10;
  // file2.cpp
  extern const int cat;
  ```

#### const对引用的影响

* 对`const`的引用常称为**常量引用**。
* `const`引用可以指向同类型的非`const`对象，但非`const`引用不可以指向同类型的`const`对象。
* `const`引用指向**同类型**的非`const`对象时，不可以更改指向的对象（引用自带的性质），也不可以通过引用改变指向对象的值，但指向的非`const`对象的值可以通过其他方式改变，只有在这种情况下，`const`引用的值才会发生变化。
* 与普通引用不同，对`const`的引用允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可，甚至可以是非常量的对象、字面值、一般表达式。

```c++
int cat = 5;
const int &dog = cat;
dog = 10; // 非法
cat = 10; // 合法，dog的值也会随之改变
```

如果给`const`引用赋值的时候，等号右端类型与`const`引用的类型不匹配，或右端是表达式时，会生成一个临时变量，引用会指向这个临时变量，而原始变量或表达式中的某个变量发生变化时，引用指向的值不会受到影响。

但是，把一个非`const`的引用指向临时量是非法的。

#### const对指针的影响

指向`const`的指针可以指向同类型的非`const`对象，但非`const`指针不可以指向同类型的`const`对象。

如果给指向`const`的指针赋值的时候，等号右端类型与`const`指针的类型不匹配，就会直接报错。

```c++
// 把常规变量的地址赋给const指针
int age = 40;
const int * pt = &age; // pt指向一个const int，不能通过pt修改这个值，但age本身可以修改，pt也可以修改指向其他位置
age += 5;  // 正确
*pt  = 20; // 错误

int s = 3;
const int * ps1 = &s;
int * const ps2 = &s; // ps2是不可改变的，但可以通过*ps2改变它指向的值
// *ps1和ps2是常量，ps1和*ps2是可变的

// 可以把const变量的地址赋给const指针，不可以把const变量的地址赋给常规指针
const float a = 9.80;
const float * pa = &a; // 正确

const float b = 1.63;
float * pb = &b; // 错误
```

指针是一个对象，允许把指针本身定义为`const`，定义时必须初始化；但是引用不可以定义为`const`

```c++
int *const pt = &cat; // 正确
int &const dog = cat; // 错误
```

#### 顶层const和底层const

* 顶层`const`：一般的`const`常量和`const`指针
* 底层`const`：指向常量的指针、指向常量的引用

进行拷贝操作时，顶层`const`可以忽略，但是底层的`const`必须一致或可以转换。

#### 常量表达式

常量表达式是指值不会改变，且在编译过程就可以得到计算结果的表达式。包括字面值、以及用常量表达式初始化的`const`对象。

#### constexpr类型

C++11新标准：

`constexpr`类型的对象一定是一个常量，而且必须用常量表达式初始化。

```c++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size();       // 只有当size()函数的返回值是constexpr类型时才正确
```

字面值类型：声明`constexpr`对象时用到的类型

![字面值类型包括哪些？](E:\GitHub\MyCppPrimer\Chapter02\literal_type.png)

`constexpr`指针只能指向静态存储对象，不能指向函数体内的对象。

`constexpr`指针可以指向常量，也可以指向非常量。需要注意的是，`constexpr`指针是顶层`const`。

### 类型别名

1. 使用`typedef`关键字
2. C++11新标准——使用别名声明

```c++
typedef double base, *p; // base是double的同义词，p是double*的同义词

using SI = Sales_item;   // SI是Sales_item的同义词
```

注意，当声明类型别名涉及到指针时，如上面的p，在与`const`一起使用时，不是简单的替换，而是把它当作一个新的类型，顶层`const`

```c++
double cat = 10.0;
const p = &cat;       // p是一个常量指针，顶层const

// 与上面不同
const double *p = &cat; // p是一个指向常量的指针，底层const
```

### auto类型说明符

auto定义的变量必须有初始值。编译器通过初始值判断变量的类型。

使用auto也可以在一条语句中声明多个变量，但该语句中所有变量的初始基本数据类型必须相同。

```c++
auto i = 0;
const int ci = i, &cr = ci;
auto b = ci;  // int
auto c = cr;  // int
auto d = &i;  // int*
auto e = &ci; // const int*
```

如果希望推断出的`auto`类型是一个顶层`const`，需要明确指出

```c++
const auto f = ci;
```

`auto`和引用

```c++
auto &g = ci;       // int&
auto &h = 42;       // 错误
const auto &h = 42; // const int&
auto &n = i, *p2 = &ci; // 错误 int, const int 同一行类型不同
```

### decltype

`decltype`分析表达式，返回其类型，但不实际计算表达式的值。

```c++
int a = 5, *p = &a, c = 10;
decltype(*p) b = c; // int& 解引用之后的类型是引用类型
decltype((a)) d = c; // 变量加括号之后变为表达式，表达式的类型都为引用
```

### 结构

C++11新标准，可以提供**类内初始值**。使用花括号或者等号初始化都可以，但是不能使用圆括号。

在C++中，struct和class的唯一区别就是struct的成员默认为public，而class默认为private。