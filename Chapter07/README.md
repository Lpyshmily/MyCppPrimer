## Chapter07
### 默认构造函数
```c++
Sales_data() = default;
```
### 构造函数初始值列表

这一部分应属于成员函数定义部分。如果成员函数在头文件中声明，在源文件中定义，那么函数初始化列表应该在源文件中。

### 友元函数

友元函数除了在类定义中声明（最前面加`friend`关键字），最好在在头文件中类外面再进行一次声明，这次声明时不需要加`friend`关键字。
### 类定义的类型别名
由类定义的类型名字和其他成员一样存在访问限制，可以是`public`或`private`中的一种。

用来定义类型的成员必须先定义后使用。
### inline函数
* 定义在类内部的成员函数自动是`inline`的。
* 可以在类内部把`inline`作为声明的一部分**显式地**声明内联函数。
* 也可以在类的外部用`inline`关键字修饰函数的定义。
* 内联函数的定义要放在头文件中。

### 可变数据成员mutable
在类成员定义的前面加上`mutable`，它就是一个可变数据成员。

可变数据成员永远不会是`const`，即使它是`const`类对象的成员。

所有成员函数都可以改变它，即使是`const`函数也可以改变它的值。

### 类的作用域

一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字己经在内层作用域中使用过。

而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。

作用域可以分为三类：成员函数内部，类内部，类外部（类声明之前）。

如果同名发生了隐藏，在函数内部调用类成员需要用`className::name`，调用类外部变量需要用`::name`。

### 委托构造函数

成员初始化列表只有一个入口，就是类名本身，后面小括号内的参数列表必须与类中另外一个构造函数匹配。

调用委托构造函数时，先执行受委托的构造函数的初始化列表和函数体，再执行本身的。

```c++
class Sales_data
{
    Sales_data(string s, unsigned cnt, double price) :
    	bookNo(s), units_sold(cnt), revenue(cnt * price) {}
    Sales_data(): Sales_data("", 0, 0) {}
    Sales_data(string s) : Sales_data(s, 0, 0) {}
    Sales_data(istream &is) : Sales_data() { read(is, *this); }
};
```

### 转换构造函数

只接受一个实参的构造函数，称为**转换构造函数**，提供了一种隐式转换机制。

编译器只会执行一步类型转换。

在类定义中，将构造函数声明前面加上`explicit`关键字（类外部进行函数定义时不需要加），就可以阻止这种隐式转换的发生，但仍然可以使用强制转换。







